tic;
clc;
clear;
close all;
% 產生10^6個bits，隨機的1和0
N=1000;
% randn函數產生常態分佈的偽隨機數
% 設定SNRdB範圍0~25,每1取一點  
SNRdB=0:1:25;
% 天線數目
TXNUM=2;
% 產生雜訊 Es,Eb 在此比較(要會算)
SNR=10.^(SNRdB/10);%Es 
SNRb=1/2*(10.^((SNRdB)/10));%Eb
% BER理論值
BPSK = 1/2*erfc(sqrt(SNR));
Bits = zeros(1,length(SNR));
% 看跑幾個bits，除以幾
B = 64;
array = [0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,1;0,0,0,0,0,0,1,0;0,0,0,0,0,0,1,1;0,0,0,0,0,1,0,0;0,0,0,0,0,1,0,1;0,0,0,0,0,1,1,0;0,0,0,0,0,1,1,1;0,0,0,0,1,0,0,0;0,0,0,0,1,0,0,1;0,0,0,0,1,0,1,0;0,0,0,0,1,0,1,1;0,0,0,0,1,1,0,0;0,0,0,0,1,1,0,1;0,0,0,0,1,1,1,0;0,0,0,0,1,1,1,1;0,0,0,1,0,0,0,0;0,0,0,1,0,0,0,1;0,0,0,1,0,0,1,0;0,0,0,1,0,0,1,1;0,0,0,1,0,1,0,0;0,0,0,1,0,1,0,1;0,0,0,1,0,1,1,0;0,0,0,1,0,1,1,1;0,0,0,1,1,0,0,0;0,0,0,1,1,0,0,1;0,0,0,1,1,0,1,0;0,0,0,1,1,0,1,1;0,0,0,1,1,1,0,0;0,0,0,1,1,1,0,1;0,0,0,1,1,1,1,0;0,0,0,1,1,1,1,1;0,0,1,0,0,0,0,0;0,0,1,0,0,0,0,1;0,0,1,0,0,0,1,0;0,0,1,0,0,0,1,1;0,0,1,0,0,1,0,0;0,0,1,0,0,1,0,1;0,0,1,0,0,1,1,0;0,0,1,0,0,1,1,1;0,0,1,0,1,0,0,0;0,0,1,0,1,0,0,1;0,0,1,0,1,0,1,0;0,0,1,0,1,0,1,1;0,0,1,0,1,1,0,0;0,0,1,0,1,1,0,1;0,0,1,0,1,1,1,0;0,0,1,0,1,1,1,1;0,0,1,1,0,0,0,0;0,0,1,1,0,0,0,1;0,0,1,1,0,0,1,0;0,0,1,1,0,0,1,1;0,0,1,1,0,1,0,0;0,0,1,1,0,1,0,1;0,0,1,1,0,1,1,0;0,0,1,1,0,1,1,1;0,0,1,1,1,0,0,0;0,0,1,1,1,0,0,1;0,0,1,1,1,0,1,0;0,0,1,1,1,0,1,1;0,0,1,1,1,1,0,0;0,0,1,1,1,1,0,1;0,0,1,1,1,1,1,0;0,0,1,1,1,1,1,1;0,1,0,0,0,0,0,0;0,1,0,0,0,0,0,1;0,1,0,0,0,0,1,0;0,1,0,0,0,0,1,1;0,1,0,0,0,1,0,0;0,1,0,0,0,1,0,1;0,1,0,0,0,1,1,0;0,1,0,0,0,1,1,1;0,1,0,0,1,0,0,0;0,1,0,0,1,0,0,1;0,1,0,0,1,0,1,0;0,1,0,0,1,0,1,1;0,1,0,0,1,1,0,0;0,1,0,0,1,1,0,1;0,1,0,0,1,1,1,0;0,1,0,0,1,1,1,1;0,1,0,1,0,0,0,0;0,1,0,1,0,0,0,1;0,1,0,1,0,0,1,0;0,1,0,1,0,0,1,1;0,1,0,1,0,1,0,0;0,1,0,1,0,1,0,1;0,1,0,1,0,1,1,0;0,1,0,1,0,1,1,1;0,1,0,1,1,0,0,0;0,1,0,1,1,0,0,1;0,1,0,1,1,0,1,0;0,1,0,1,1,0,1,1;0,1,0,1,1,1,0,0;0,1,0,1,1,1,0,1;0,1,0,1,1,1,1,0;0,1,0,1,1,1,1,1;0,1,1,0,0,0,0,0;0,1,1,0,0,0,0,1;0,1,1,0,0,0,1,0;0,1,1,0,0,0,1,1;0,1,1,0,0,1,0,0;0,1,1,0,0,1,0,1;0,1,1,0,0,1,1,0;0,1,1,0,0,1,1,1;0,1,1,0,1,0,0,0;0,1,1,0,1,0,0,1;0,1,1,0,1,0,1,0;0,1,1,0,1,0,1,1;0,1,1,0,1,1,0,0;0,1,1,0,1,1,0,1;0,1,1,0,1,1,1,0;0,1,1,0,1,1,1,1;0,1,1,1,0,0,0,0;0,1,1,1,0,0,0,1;0,1,1,1,0,0,1,0;0,1,1,1,0,0,1,1;0,1,1,1,0,1,0,0;0,1,1,1,0,1,0,1;0,1,1,1,0,1,1,0;0,1,1,1,0,1,1,1;0,1,1,1,1,0,0,0;0,1,1,1,1,0,0,1;0,1,1,1,1,0,1,0;0,1,1,1,1,0,1,1;0,1,1,1,1,1,0,0;0,1,1,1,1,1,0,1;0,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1;1,0,0,0,0,0,0,0;1,0,0,0,0,0,0,1;1,0,0,0,0,0,1,0;1,0,0,0,0,0,1,1;1,0,0,0,0,1,0,0;1,0,0,0,0,1,0,1;1,0,0,0,0,1,1,0;1,0,0,0,0,1,1,1;1,0,0,0,1,0,0,0;1,0,0,0,1,0,0,1;1,0,0,0,1,0,1,0;1,0,0,0,1,0,1,1;1,0,0,0,1,1,0,0;1,0,0,0,1,1,0,1;1,0,0,0,1,1,1,0;1,0,0,0,1,1,1,1;1,0,0,1,0,0,0,0;1,0,0,1,0,0,0,1;1,0,0,1,0,0,1,0;1,0,0,1,0,0,1,1;1,0,0,1,0,1,0,0;1,0,0,1,0,1,0,1;1,0,0,1,0,1,1,0;1,0,0,1,0,1,1,1;1,0,0,1,1,0,0,0;1,0,0,1,1,0,0,1;1,0,0,1,1,0,1,0;1,0,0,1,1,0,1,1;1,0,0,1,1,1,0,0;1,0,0,1,1,1,0,1;1,0,0,1,1,1,1,0;1,0,0,1,1,1,1,1;1,0,1,0,0,0,0,0;1,0,1,0,0,0,0,1;1,0,1,0,0,0,1,0;1,0,1,0,0,0,1,1;1,0,1,0,0,1,0,0;1,0,1,0,0,1,0,1;1,0,1,0,0,1,1,0;1,0,1,0,0,1,1,1;1,0,1,0,1,0,0,0;1,0,1,0,1,0,0,1;1,0,1,0,1,0,1,0;1,0,1,0,1,0,1,1;1,0,1,0,1,1,0,0;1,0,1,0,1,1,0,1;1,0,1,0,1,1,1,0;1,0,1,0,1,1,1,1;1,0,1,1,0,0,0,0;1,0,1,1,0,0,0,1;1,0,1,1,0,0,1,0;1,0,1,1,0,0,1,1;1,0,1,1,0,1,0,0;1,0,1,1,0,1,0,1;1,0,1,1,0,1,1,0;1,0,1,1,0,1,1,1;1,0,1,1,1,0,0,0;1,0,1,1,1,0,0,1;1,0,1,1,1,0,1,0;1,0,1,1,1,0,1,1;1,0,1,1,1,1,0,0;1,0,1,1,1,1,0,1;1,0,1,1,1,1,1,0;1,0,1,1,1,1,1,1;1,1,0,0,0,0,0,0;1,1,0,0,0,0,0,1;1,1,0,0,0,0,1,0;1,1,0,0,0,0,1,1;1,1,0,0,0,1,0,0;1,1,0,0,0,1,0,1;1,1,0,0,0,1,1,0;1,1,0,0,0,1,1,1;1,1,0,0,1,0,0,0;1,1,0,0,1,0,0,1;1,1,0,0,1,0,1,0;1,1,0,0,1,0,1,1;1,1,0,0,1,1,0,0;1,1,0,0,1,1,0,1;1,1,0,0,1,1,1,0;1,1,0,0,1,1,1,1;1,1,0,1,0,0,0,0;1,1,0,1,0,0,0,1;1,1,0,1,0,0,1,0;1,1,0,1,0,0,1,1;1,1,0,1,0,1,0,0;1,1,0,1,0,1,0,1;1,1,0,1,0,1,1,0;1,1,0,1,0,1,1,1;1,1,0,1,1,0,0,0;1,1,0,1,1,0,0,1;1,1,0,1,1,0,1,0;1,1,0,1,1,0,1,1;1,1,0,1,1,1,0,0;1,1,0,1,1,1,0,1;1,1,0,1,1,1,1,0;1,1,0,1,1,1,1,1;1,1,1,0,0,0,0,0;1,1,1,0,0,0,0,1;1,1,1,0,0,0,1,0;1,1,1,0,0,0,1,1;1,1,1,0,0,1,0,0;1,1,1,0,0,1,0,1;1,1,1,0,0,1,1,0;1,1,1,0,0,1,1,1;1,1,1,0,1,0,0,0;1,1,1,0,1,0,0,1;1,1,1,0,1,0,1,0;1,1,1,0,1,0,1,1;1,1,1,0,1,1,0,0;1,1,1,0,1,1,0,1;1,1,1,0,1,1,1,0;1,1,1,0,1,1,1,1;1,1,1,1,0,0,0,0;1,1,1,1,0,0,0,1;1,1,1,1,0,0,1,0;1,1,1,1,0,0,1,1;1,1,1,1,0,1,0,0;1,1,1,1,0,1,0,1;1,1,1,1,0,1,1,0;1,1,1,1,0,1,1,1;1,1,1,1,1,0,0,0;1,1,1,1,1,0,0,1;1,1,1,1,1,0,1,0;1,1,1,1,1,0,1,1;1,1,1,1,1,1,0,0;1,1,1,1,1,1,0,1;1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1];
for k = 1:26
    error_bits = 0;
    E = 0;
    for x = 1:(1/B)*N
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始編碼，產生訊號(利用BPSK調變)
        Signal_encode = randn(1,64);
        for xx = 1:1:64
            if Signal_encode(1,xx) > 0
                transmitted_message(1,xx) = 1;
            elseif Signal_encode(1,xx) <= 0
                transmitted_message(1,xx) = 0;
            end
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始走 Convolution Code 的 Trellis_Diagram，由00開始
        u1 = transmitted_message(1,1);
        s0_s1 = [0,0];
        temp = xor(u1,s0_s1(1,1));
        v0 = xor(temp,s0_s1(1,2));
        v1 = xor(u1,s0_s1(1,2));
        output = [v0,v1];
        v0_v1_1 = transpose(dec2bin(output) - '0');
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始走 Convolution Code 的 Trellis_Diagram，第二部分
        u1 = transmitted_message(1,2);
        s0_s1 = [transmitted_message(1,1),s0_s1(1,1)];
        temp = xor(u1,s0_s1(1,1));
        v0 = xor(temp,s0_s1(1,2));
        v1 = xor(u1,s0_s1(1,2));
        output = [v0,v1];
        v0_v1_2 = transpose(dec2bin(output) - '0');
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始走 Convolution Code 的 Trellis_Diagram
        for cc = 3:1:64
            u1 = transmitted_message(1,cc);
            s0_s1 = [transmitted_message(1,cc-1),s0_s1(1,1)];
            temp(1,:) = xor(u1,s0_s1(1,1));
            v0(1,:) = xor(temp,s0_s1(1,2));
            v1(1,:) = xor(u1,s0_s1(1,2));
            output(1,:) = [v0,v1];
            v0_v1_3(1,2*cc-5:2*cc-4) = transpose(dec2bin(output) - '0');
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 將v0和v1訊號由1變成1，0變成-1
        transmitted_codeword = [v0_v1_1,v0_v1_2,v0_v1_3];
        transmitted_codeword_signal = 2*[v0_v1_1,v0_v1_2,v0_v1_3] - 1;
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始做分組，分成16組
        for group = 1:16
            received_word_sample(group,:) = transmitted_codeword_signal(1,8*group-7:8*group);
            % 開始將這16組分成4個QPSK進行High Rate的Encoding
            si1(group,:) = (1/sqrt(2))*(received_word_sample(group,1) + received_word_sample(group,2)*1i);
            si2(group,:) = (1/sqrt(2))*(received_word_sample(group,3) + received_word_sample(group,4)*1i);
            si3(group,:) = (1/sqrt(2))*(received_word_sample(group,5) + received_word_sample(group,6)*1i);
            si4(group,:) = (1/sqrt(2))*(received_word_sample(group,7) + received_word_sample(group,8)*1i);
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////

        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 產生High Rate訊號
        theta1 = 63.4;
        theta2 = 90-theta1;
        for group2 = 1:16
            high_rate_array(2*group2-1:2*group2,:) = [si1(group2,:)*sind(theta1)-(conj(si2(group2,:)))*cosd(theta1),si3(group2,:)*sind(theta2)-(conj(si4(group2,:)))*cosd(theta2)
                                                     -(conj(si3(group2,:)))*sind(theta2)+si4(group2,:)*cosd(theta2),(conj(si1(group2,:)))*sind(theta1)-si2(group2,:)*cosd(theta1)];
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 產生通道雜訊:Rayleigh fading channel
        sys_ray = sqrt(0.5)*(randn(1,64) + randn(1,64)*1i);
        % 將雷利通道加入訊號
        sys_ray_array = transpose([sys_ray(1,1:32);sys_ray(1,33:64)]);
        for rray = 1:16
            r_ray(2*rray-1:2*rray,:) = high_rate_array(2*rray-1:2*rray,:)*sys_ray_array(2*rray-1:2*rray,:);
        end
        %/////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        %/////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 產生AWGN雜訊
        noise = TXNUM/(2*SNR(k)); %產生雜訊 Es-Eb的 SNR 改這裡!!
        % 產生AWGN
        sys_noise = sqrt(noise)*(randn(1,64) + randn(1,64)*1i);
        % 將雜訊加入已包含雷利通道的訊號
        AWGN_array = transpose([sys_noise(1,1:32);sys_noise(1,33:64)]);
        r = r_ray + AWGN_array;
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始解碼
        one = ones(256,8);
        array_signal = 2*array - one;
        for kkk = 1:1:256
            for kkkk = 1:1:16
                so1(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,1) + array_signal(kkk,2)*1i)];
                so2(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,3) + array_signal(kkk,4)*1i)];
                so3(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,5) + array_signal(kkk,6)*1i)];
                so4(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,7) + array_signal(kkk,8)*1i)];
                high_rate_array_decode(2*kkk-1:2*kkk,:) = [so1(kkk,:)*sind(theta1)-(conj(so2(kkk,:)))*cosd(theta1),so3(kkk,:)*sind(theta2)-(conj(so4(kkk,:)))*cosd(theta2)
                                                          -(conj(so3(kkk,:)))*sind(theta2)+so4(kkk,:)*cosd(theta2),(conj(so1(kkk,:)))*sind(theta1)-so2(kkk,:)*cosd(theta1)];
                signal_csi(2*kkk-1:2*kkk,2*kkkk-1:2*kkkk) = high_rate_array_decode(2*kkk-1:2*kkk,:)*sys_ray_array(2*kkkk-1:2*kkkk,:);
            end
        end
        for kkkkk = 1:1:16
            for kkkkkk = 1:1:256
                Distance(kkkkk,kkkkkk) = sum(sum(abs(r(2*kkkkk-1:2*kkkkk,:) - signal_csi(2*kkkkkk-1:2*kkkkkk,2*kkkkk-1:2*kkkkk))));
            end
        end
        for kkkkkkk = 1:1:16
            [minDis(kkkkkkk,:),Number(kkkkkkk,:)] = min(Distance(kkkkkkk,:));
        end    
        received_word_temp = array(Number,:);
        for c = 1:1:16
            received_word(1,8*c-7:8*c) = received_word_temp(c,:);
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始執行Convolution Code的解碼
        % 開始建構路徑圖
        road1 = [0,0;1,1];
        road2 = [1,0;0,1];
        road3 = [1,1;0,0];
        road4 = [0,1;1,0];
        road = [road1;road2;road3;road4];
        for xxxx = 1:1:2
            dis1(xxxx,:) = sum(abs(v0_v1_1 - road(xxxx,1:2)));
        end
        for xxxxx = 1:1:4
            dis2(xxxxx,:) = sum(abs(v0_v1_2 - road(xxxxx,1:2)));
        end
        for xxxxxx = 1:1:8
            for xxxxxxx = 1:1:62
                dis3(xxxxxx,xxxxxxx) = sum(abs(v0_v1_3(1,2*xxxxxxx-1:2*xxxxxxx) - road(xxxxxx,1:2)));
            end
        end
        dis = [[dis2;3;3;3;3],dis3];
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////

        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始算最小距離
        minD0 = [dis1;3;3];
        D = zeros(8,63);
        D(1,1) = minD0(1,1) + dis(1,1);
        D(3,1) = minD0(1,1) + dis(2,1);
        D(5,1) = minD0(2,1) + dis(3,1);
        D(7,1) = minD0(2,1) + dis(4,1);
        D(2,1) = minD0(3,1) + dis(5,1);
        D(4,1) = minD0(3,1) + dis(6,1);
        D(6,1) = minD0(4,1) + dis(7,1);
        D(8,1) = minD0(4,1) + dis(8,1);
        minD1 = [min(D(1:2,1));min(D(3:4,1));min(D(5:6,1));min(D(7:8,1))];
        for d = 2:1:63
            for dd = 1:1:63
                D(1,d) = minD1(1,1) + dis(1,d);
                D(3,d) = minD1(1,1) + dis(2,d);
                D(5,d) = minD1(2,1) + dis(3,d);
                D(7,d) = minD1(2,1) + dis(4,d);
                D(2,d) = minD1(3,1) + dis(5,d);
                D(4,d) = minD1(3,1) + dis(6,d);
                D(6,d) = minD1(4,1) + dis(7,d);
                D(8,d) = minD1(4,1) + dis(8,d);
                minD1 = [min(D(1:2,d-1));min(D(3:4,d-1));min(D(5:6,d-1));min(D(7:8,d-1))];
                minD2(1:4,dd) = [min(D(1:2,dd));min(D(3:4,dd));min(D(5:6,dd));min(D(7:8,dd))];
            end
        end
        minD = [minD0,minD2];
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////

        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始找最佳路徑
        decode_road = [road2;road4;road1;road3];
        for ddd = 64:-1:2
            [minD(:,ddd),number(1,ddd-1)] = min(D(8:-1:1,ddd-1));
        end
        % 開始判別訊號
        decoded_message = zeros(1,64);
        if received_word(1,1:2) == [0,0]
            decoded_message(1,1) = 0;
        elseif received_word(1,1:2) == [1,1]
            decoded_message(1,1) = 1;
        end
        if received_word(1,3:4) == [0,0] | received_word(1,1:2) == [1,0]
            decoded_message(1,2) = 0;
        elseif received_word(1,3:4) == [1,1] | received_word(1,3:4) == [0,1]
            decoded_message(1,2) = 1;
        end
        for dddd = 3:1:64
            if number(1,dddd-1) == 2 || number(1,dddd-1) == 4 || number(1,dddd-1) == 6 || number(1,dddd-1) == 8
                if received_word(1,2*dddd-1:2*dddd) == [0,0] | received_word(1,2*dddd-1:2*dddd) == [1,0]
                    decoded_message(1,dddd) = 0;
                elseif received_word(1,2*dddd-1:2*dddd) == [1,1] | received_word(1,2*dddd-1:2*dddd) == [0,1]
                    decoded_message(1,dddd) = 1;
                end
            elseif number(1,dddd-1) == 1 || number(1,dddd-1) == 3 || number(1,dddd-1) == 5 || number(1,dddd-1) == 7
                if received_word(1,2*dddd-1:2*dddd) == [0,0] | received_word(1,2*dddd-1:2*dddd) == [1,0]
                    decoded_message(1,dddd) = 1;
                elseif received_word(1,2*dddd-1:2*dddd) == [1,1] | received_word(1,2*dddd-1:2*dddd) == [0,1]
                    decoded_message(1,dddd) = 0;
                end
            end
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % 統計錯誤的bits數
        error_bits = sum(abs(transmitted_message - decoded_message));
        % 錯誤總bits數
        E = error_bits + E;
    end
    % 算出錯誤率並計算錯誤率和訊雜比的關係
    Error(k) = E;
    Bits = sum(Error(:));
    BER = [0.272583,0.252380,0.229664,0.206013,0.181326,0.154674,0.130210,0.105127,0.081928,0.062154,0.044431,0.030685,0.020580,0.013016,0.007702,0.004268,0.002377,0.001256,0.000589,0.000275,0.000129,0.000061,0.000041,0.000008,0.000001,0];
    TheoryBER(k) = E/(N);
end
% semilogy函數可以使用y軸的對數刻度繪製數據
figure
semilogy(SNRdB,BER, 'B-V',SNRdB,TheoryBER, 'R-O');
grid on ;
legend('(2,1,2)Convolution_Codes and High Rate','(2,1,3)Convolution_Codes and High Rate');
axis([0 25 10^-6 10^0]);
% 將曲線圖之標題，X軸，Y軸各作標示
title('Curve for BER v.s SNR for Convolution_Codes and High Rate');
xlabel('Es/N0');
ylabel('BER');
toc;