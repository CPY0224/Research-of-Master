tic;
clc;
clear;
close all;
% 產生10^6個bits，隨機的1和0
N=10^8;
% randn函數產生常態分佈的偽隨機數
% 設定SNRdB範圍0~25,每1取一點  
SNRdB=0:1:20;
% 天線數目
TXNUM=2;
% 產生雜訊 Es,Eb 在此比較(要會算)
SNR=10.^(SNRdB/10);%Es
SNRb=2*(10.^((SNRdB)/10));%Eb,HRSTBC=4 X CC=1/2 = 2
% BER理論值
BPSK = 1/2*erfc(sqrt(SNR));
Bits = zeros(1,length(SNR));
% 看跑幾個bits，除以幾
B = 64;
array = [0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,1;0,0,0,0,0,0,1,0;0,0,0,0,0,0,1,1;0,0,0,0,0,1,0,0;0,0,0,0,0,1,0,1;0,0,0,0,0,1,1,0;0,0,0,0,0,1,1,1;0,0,0,0,1,0,0,0;0,0,0,0,1,0,0,1;0,0,0,0,1,0,1,0;0,0,0,0,1,0,1,1;0,0,0,0,1,1,0,0;0,0,0,0,1,1,0,1;0,0,0,0,1,1,1,0;0,0,0,0,1,1,1,1;0,0,0,1,0,0,0,0;0,0,0,1,0,0,0,1;0,0,0,1,0,0,1,0;0,0,0,1,0,0,1,1;0,0,0,1,0,1,0,0;0,0,0,1,0,1,0,1;0,0,0,1,0,1,1,0;0,0,0,1,0,1,1,1;0,0,0,1,1,0,0,0;0,0,0,1,1,0,0,1;0,0,0,1,1,0,1,0;0,0,0,1,1,0,1,1;0,0,0,1,1,1,0,0;0,0,0,1,1,1,0,1;0,0,0,1,1,1,1,0;0,0,0,1,1,1,1,1;0,0,1,0,0,0,0,0;0,0,1,0,0,0,0,1;0,0,1,0,0,0,1,0;0,0,1,0,0,0,1,1;0,0,1,0,0,1,0,0;0,0,1,0,0,1,0,1;0,0,1,0,0,1,1,0;0,0,1,0,0,1,1,1;0,0,1,0,1,0,0,0;0,0,1,0,1,0,0,1;0,0,1,0,1,0,1,0;0,0,1,0,1,0,1,1;0,0,1,0,1,1,0,0;0,0,1,0,1,1,0,1;0,0,1,0,1,1,1,0;0,0,1,0,1,1,1,1;0,0,1,1,0,0,0,0;0,0,1,1,0,0,0,1;0,0,1,1,0,0,1,0;0,0,1,1,0,0,1,1;0,0,1,1,0,1,0,0;0,0,1,1,0,1,0,1;0,0,1,1,0,1,1,0;0,0,1,1,0,1,1,1;0,0,1,1,1,0,0,0;0,0,1,1,1,0,0,1;0,0,1,1,1,0,1,0;0,0,1,1,1,0,1,1;0,0,1,1,1,1,0,0;0,0,1,1,1,1,0,1;0,0,1,1,1,1,1,0;0,0,1,1,1,1,1,1;0,1,0,0,0,0,0,0;0,1,0,0,0,0,0,1;0,1,0,0,0,0,1,0;0,1,0,0,0,0,1,1;0,1,0,0,0,1,0,0;0,1,0,0,0,1,0,1;0,1,0,0,0,1,1,0;0,1,0,0,0,1,1,1;0,1,0,0,1,0,0,0;0,1,0,0,1,0,0,1;0,1,0,0,1,0,1,0;0,1,0,0,1,0,1,1;0,1,0,0,1,1,0,0;0,1,0,0,1,1,0,1;0,1,0,0,1,1,1,0;0,1,0,0,1,1,1,1;0,1,0,1,0,0,0,0;0,1,0,1,0,0,0,1;0,1,0,1,0,0,1,0;0,1,0,1,0,0,1,1;0,1,0,1,0,1,0,0;0,1,0,1,0,1,0,1;0,1,0,1,0,1,1,0;0,1,0,1,0,1,1,1;0,1,0,1,1,0,0,0;0,1,0,1,1,0,0,1;0,1,0,1,1,0,1,0;0,1,0,1,1,0,1,1;0,1,0,1,1,1,0,0;0,1,0,1,1,1,0,1;0,1,0,1,1,1,1,0;0,1,0,1,1,1,1,1;0,1,1,0,0,0,0,0;0,1,1,0,0,0,0,1;0,1,1,0,0,0,1,0;0,1,1,0,0,0,1,1;0,1,1,0,0,1,0,0;0,1,1,0,0,1,0,1;0,1,1,0,0,1,1,0;0,1,1,0,0,1,1,1;0,1,1,0,1,0,0,0;0,1,1,0,1,0,0,1;0,1,1,0,1,0,1,0;0,1,1,0,1,0,1,1;0,1,1,0,1,1,0,0;0,1,1,0,1,1,0,1;0,1,1,0,1,1,1,0;0,1,1,0,1,1,1,1;0,1,1,1,0,0,0,0;0,1,1,1,0,0,0,1;0,1,1,1,0,0,1,0;0,1,1,1,0,0,1,1;0,1,1,1,0,1,0,0;0,1,1,1,0,1,0,1;0,1,1,1,0,1,1,0;0,1,1,1,0,1,1,1;0,1,1,1,1,0,0,0;0,1,1,1,1,0,0,1;0,1,1,1,1,0,1,0;0,1,1,1,1,0,1,1;0,1,1,1,1,1,0,0;0,1,1,1,1,1,0,1;0,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1;1,0,0,0,0,0,0,0;1,0,0,0,0,0,0,1;1,0,0,0,0,0,1,0;1,0,0,0,0,0,1,1;1,0,0,0,0,1,0,0;1,0,0,0,0,1,0,1;1,0,0,0,0,1,1,0;1,0,0,0,0,1,1,1;1,0,0,0,1,0,0,0;1,0,0,0,1,0,0,1;1,0,0,0,1,0,1,0;1,0,0,0,1,0,1,1;1,0,0,0,1,1,0,0;1,0,0,0,1,1,0,1;1,0,0,0,1,1,1,0;1,0,0,0,1,1,1,1;1,0,0,1,0,0,0,0;1,0,0,1,0,0,0,1;1,0,0,1,0,0,1,0;1,0,0,1,0,0,1,1;1,0,0,1,0,1,0,0;1,0,0,1,0,1,0,1;1,0,0,1,0,1,1,0;1,0,0,1,0,1,1,1;1,0,0,1,1,0,0,0;1,0,0,1,1,0,0,1;1,0,0,1,1,0,1,0;1,0,0,1,1,0,1,1;1,0,0,1,1,1,0,0;1,0,0,1,1,1,0,1;1,0,0,1,1,1,1,0;1,0,0,1,1,1,1,1;1,0,1,0,0,0,0,0;1,0,1,0,0,0,0,1;1,0,1,0,0,0,1,0;1,0,1,0,0,0,1,1;1,0,1,0,0,1,0,0;1,0,1,0,0,1,0,1;1,0,1,0,0,1,1,0;1,0,1,0,0,1,1,1;1,0,1,0,1,0,0,0;1,0,1,0,1,0,0,1;1,0,1,0,1,0,1,0;1,0,1,0,1,0,1,1;1,0,1,0,1,1,0,0;1,0,1,0,1,1,0,1;1,0,1,0,1,1,1,0;1,0,1,0,1,1,1,1;1,0,1,1,0,0,0,0;1,0,1,1,0,0,0,1;1,0,1,1,0,0,1,0;1,0,1,1,0,0,1,1;1,0,1,1,0,1,0,0;1,0,1,1,0,1,0,1;1,0,1,1,0,1,1,0;1,0,1,1,0,1,1,1;1,0,1,1,1,0,0,0;1,0,1,1,1,0,0,1;1,0,1,1,1,0,1,0;1,0,1,1,1,0,1,1;1,0,1,1,1,1,0,0;1,0,1,1,1,1,0,1;1,0,1,1,1,1,1,0;1,0,1,1,1,1,1,1;1,1,0,0,0,0,0,0;1,1,0,0,0,0,0,1;1,1,0,0,0,0,1,0;1,1,0,0,0,0,1,1;1,1,0,0,0,1,0,0;1,1,0,0,0,1,0,1;1,1,0,0,0,1,1,0;1,1,0,0,0,1,1,1;1,1,0,0,1,0,0,0;1,1,0,0,1,0,0,1;1,1,0,0,1,0,1,0;1,1,0,0,1,0,1,1;1,1,0,0,1,1,0,0;1,1,0,0,1,1,0,1;1,1,0,0,1,1,1,0;1,1,0,0,1,1,1,1;1,1,0,1,0,0,0,0;1,1,0,1,0,0,0,1;1,1,0,1,0,0,1,0;1,1,0,1,0,0,1,1;1,1,0,1,0,1,0,0;1,1,0,1,0,1,0,1;1,1,0,1,0,1,1,0;1,1,0,1,0,1,1,1;1,1,0,1,1,0,0,0;1,1,0,1,1,0,0,1;1,1,0,1,1,0,1,0;1,1,0,1,1,0,1,1;1,1,0,1,1,1,0,0;1,1,0,1,1,1,0,1;1,1,0,1,1,1,1,0;1,1,0,1,1,1,1,1;1,1,1,0,0,0,0,0;1,1,1,0,0,0,0,1;1,1,1,0,0,0,1,0;1,1,1,0,0,0,1,1;1,1,1,0,0,1,0,0;1,1,1,0,0,1,0,1;1,1,1,0,0,1,1,0;1,1,1,0,0,1,1,1;1,1,1,0,1,0,0,0;1,1,1,0,1,0,0,1;1,1,1,0,1,0,1,0;1,1,1,0,1,0,1,1;1,1,1,0,1,1,0,0;1,1,1,0,1,1,0,1;1,1,1,0,1,1,1,0;1,1,1,0,1,1,1,1;1,1,1,1,0,0,0,0;1,1,1,1,0,0,0,1;1,1,1,1,0,0,1,0;1,1,1,1,0,0,1,1;1,1,1,1,0,1,0,0;1,1,1,1,0,1,0,1;1,1,1,1,0,1,1,0;1,1,1,1,0,1,1,1;1,1,1,1,1,0,0,0;1,1,1,1,1,0,0,1;1,1,1,1,1,0,1,0;1,1,1,1,1,0,1,1;1,1,1,1,1,1,0,0;1,1,1,1,1,1,0,1;1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1];
for k = 1:21
    error_bits = 0;
    E = 0;
    if k <= 10
        N = 10;
    elseif 10 < k && k <= 17
        N = 10;
    elseif 17 < k && k <= 21
        N = 10^8;
    end
    for x = 1:(1/B)*N
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始編碼，產生訊號(利用BPSK調變)
        Signal_encode = randn(1,64);
        for xx = 1:1:64
            if Signal_encode(1,xx) > 0
                transmitted_message(1,xx) = 1;
            elseif Signal_encode(1,xx) <= 0
                transmitted_message(1,xx) = 0;
            end
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始走 Convolution Code 的 Trellis_Diagram，由00開始
%         trellis = poly2trellis(3,[5 7]);%for 212
%         trellis = poly2trellis(4,[15 17]);%for 213
%         trellis = poly2trellis(5,[23 35]);%for 214
%         trellis = poly2trellis(6,[53 75]);%for 215
%         trellis = poly2trellis(7,[133 171]);%for 216
%         trellis = poly2trellis(8,[247 371]);%for 217
%         trellis = poly2trellis(9,[561 753]);%for 218
        trellis = poly2trellis(10,[1167 1545]);%for 219
        codedData = convenc(transmitted_message,trellis);
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 將訊號由1變成1，0變成-1
        transmitted_codeword_signal = 2*codedData - 1;
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始做分組，分成16組
        for group = 1:16
            received_word_sample(group,:) = transmitted_codeword_signal(1,8*group-7:8*group);
            % 開始將這16組分成4個QPSK進行High Rate的Encoding
            si1(group,:) = (1/sqrt(2))*(received_word_sample(group,1) + received_word_sample(group,2)*1i);
            si2(group,:) = (1/sqrt(2))*(received_word_sample(group,3) + received_word_sample(group,4)*1i);
            si3(group,:) = (1/sqrt(2))*(received_word_sample(group,5) + received_word_sample(group,6)*1i);
            si4(group,:) = (1/sqrt(2))*(received_word_sample(group,7) + received_word_sample(group,8)*1i);
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////

        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 產生High Rate訊號
        theta1 = 63.4;
        theta2 = 90-theta1;
        for group2 = 1:16
            high_rate_array(2*group2-1:2*group2,:) = [si1(group2,:)*sind(theta1)-(conj(si2(group2,:)))*cosd(theta1),si3(group2,:)*sind(theta2)-(conj(si4(group2,:)))*cosd(theta2)
                                                     -(conj(si3(group2,:)))*sind(theta2)+si4(group2,:)*cosd(theta2),(conj(si1(group2,:)))*sind(theta1)-si2(group2,:)*cosd(theta1)];
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 產生通道雜訊:Rayleigh fading channel
        sys_ray = sqrt(0.5)*(randn(1,64) + randn(1,64)*1i);
        % 將雷利通道加入訊號
        sys_ray_array = transpose([sys_ray(1,1:32);sys_ray(1,33:64)]);
        for rray = 1:16
            r_ray(2*rray-1:2*rray,:) = high_rate_array(2*rray-1:2*rray,:)*sys_ray_array(2*rray-1:2*rray,:);
        end
        %/////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        %/////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 產生AWGN雜訊
        noise = TXNUM/(2*SNR(k)); %產生雜訊 Es-Eb的 SNR 改這裡!!
        % 產生AWGN
        sys_noise = sqrt(noise)*(randn(1,64) + randn(1,64)*1i);
        % 將雜訊加入已包含雷利通道的訊號
        AWGN_array = transpose([sys_noise(1,1:32);sys_noise(1,33:64)]);
        r = r_ray + AWGN_array;
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始解碼
        one = ones(256,8);
        array_signal = 2*array - one;
        for kkk = 1:1:256
            for kkkk = 1:1:16
                so1(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,1) + array_signal(kkk,2)*1i)];
                so2(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,3) + array_signal(kkk,4)*1i)];
                so3(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,5) + array_signal(kkk,6)*1i)];
                so4(kkk,:) = (1/sqrt(2))*[(array_signal(kkk,7) + array_signal(kkk,8)*1i)];
                high_rate_array_decode(2*kkk-1:2*kkk,:) = [so1(kkk,:)*sind(theta1)-(conj(so2(kkk,:)))*cosd(theta1),so3(kkk,:)*sind(theta2)-(conj(so4(kkk,:)))*cosd(theta2)
                                                          -(conj(so3(kkk,:)))*sind(theta2)+so4(kkk,:)*cosd(theta2),(conj(so1(kkk,:)))*sind(theta1)-so2(kkk,:)*cosd(theta1)];
                signal_csi(2*kkk-1:2*kkk,2*kkkk-1:2*kkkk) = high_rate_array_decode(2*kkk-1:2*kkk,:)*sys_ray_array(2*kkkk-1:2*kkkk,:);
            end
        end
        for kkkkk = 1:1:16 
            for kkkkkk = 1:1:256
                Distance(kkkkk,kkkkkk) = sum(sum(abs(r(2*kkkkk-1:2*kkkkk,:) - signal_csi(2*kkkkkk-1:2*kkkkkk,2*kkkkk-1:2*kkkkk))));
            end
        end
        for kkkkkkk = 1:1:16
            [minDis(kkkkkkk,:),Number(kkkkkkk,:)] = min(Distance(kkkkkkk,:));
        end    
        received_word_temp = array(Number,:);
        for c = 1:1:16
            received_word(1,8*c-7:8*c) = received_word_temp(c,:);
        end
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        % 開始算最小距離
        tbdepth = 64;
        decoded_message = vitdec(received_word,trellis,tbdepth,'trunc','hard');
        % /////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        % 統計錯誤的bits數
        error_bits = sum(abs(transmitted_message - decoded_message));
        % 錯誤總bits數
        E = error_bits + E;
    end
    % 算出錯誤率並計算錯誤率和訊雜比的關係
    Error(k) = E;
    Bits = sum(Error(:));
    BER(k) = E/(N);
end
% semilogy函數可以使用y軸的對數刻度繪製數據
figure
semilogy(SNRdB,BER, 'B-V');
grid on ;
legend('CC add HRSTBC');
axis([0 25 10^-8 10^0]);
% 將曲線圖之標題，X軸，Y軸各作標示
title('Convolution Codes Concatenated High Rate，CR=2');
xlabel('Es/N0');
ylabel('BER');
toc;